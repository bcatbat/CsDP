- [Creational Patterns](#creational-patterns)
  - [Abstact Factory](#abstact-factory)
    - [定义<抽象工厂>](#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82)
    - [UML<抽象工厂>](#uml%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82)
    - [构成<抽象工厂>](#%E6%9E%84%E6%88%90%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82)
  - [Builder](#builder)
    - [定义<建造>](#%E5%AE%9A%E4%B9%89%E5%BB%BA%E9%80%A0)
    - [UML<建造>](#uml%E5%BB%BA%E9%80%A0)
    - [构成<建造>](#%E6%9E%84%E6%88%90%E5%BB%BA%E9%80%A0)
  - [Factory Method](#factory-method)
    - [定义<工厂方法>](#%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95)
    - [UML<工厂方法>](#uml%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95)
    - [构成<工厂方法>](#%E6%9E%84%E6%88%90%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95)
  - [Prototype](#prototype)
    - [定义<原型>](#%E5%AE%9A%E4%B9%89%E5%8E%9F%E5%9E%8B)
    - [UML<原型>](#uml%E5%8E%9F%E5%9E%8B)
    - [构成<原型>](#%E6%9E%84%E6%88%90%E5%8E%9F%E5%9E%8B)
  - [Singleton](#singleton)
    - [定义<单例>](#%E5%AE%9A%E4%B9%89%E5%8D%95%E4%BE%8B)
    - [UML<单例>](#uml%E5%8D%95%E4%BE%8B)
    - [构成<单例>](#%E6%9E%84%E6%88%90%E5%8D%95%E4%BE%8B)
    - [运用<单例>](#%E8%BF%90%E7%94%A8%E5%8D%95%E4%BE%8B)
- [Structual Patterns](#structual-patterns)
  - [Adapter](#adapter)
    - [定义<适配>](#%E5%AE%9A%E4%B9%89%E9%80%82%E9%85%8D)
    - [UML<适配>](#uml%E9%80%82%E9%85%8D)
    - [构成<适配>](#%E6%9E%84%E6%88%90%E9%80%82%E9%85%8D)
  - [Bridge](#bridge)
    - [定义<桥接>](#%E5%AE%9A%E4%B9%89%E6%A1%A5%E6%8E%A5)
    - [UML<桥接>](#uml%E6%A1%A5%E6%8E%A5)
    - [构成<桥接>](#%E6%9E%84%E6%88%90%E6%A1%A5%E6%8E%A5)
  - [Composite](#composite)
    - [定义<组合>](#%E5%AE%9A%E4%B9%89%E7%BB%84%E5%90%88)
    - [UML<组合>](#uml%E7%BB%84%E5%90%88)
    - [构成<组合>](#%E6%9E%84%E6%88%90%E7%BB%84%E5%90%88)
  - [Decorator](#decorator)
    - [定义<装饰>](#%E5%AE%9A%E4%B9%89%E8%A3%85%E9%A5%B0)
    - [UML<装饰>](#uml%E8%A3%85%E9%A5%B0)
    - [构成<装饰>](#%E6%9E%84%E6%88%90%E8%A3%85%E9%A5%B0)
  - [Facade](#facade)
    - [定义<外观>](#%E5%AE%9A%E4%B9%89%E5%A4%96%E8%A7%82)
    - [UML<外观>](#uml%E5%A4%96%E8%A7%82)
    - [构成<外观>](#%E6%9E%84%E6%88%90%E5%A4%96%E8%A7%82)
  - [Flyweight](#flyweight)
    - [定义<享元,蝇量级>](#%E5%AE%9A%E4%B9%89%E4%BA%AB%E5%85%83%E8%9D%87%E9%87%8F%E7%BA%A7)
    - [UML<享元>](#uml%E4%BA%AB%E5%85%83)
    - [构成<享元>](#%E6%9E%84%E6%88%90%E4%BA%AB%E5%85%83)
  - [Proxy](#proxy)
    - [定义<代理>](#%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%90%86)
    - [UML<代理>](#uml%E4%BB%A3%E7%90%86)
    - [构成<代理>](#%E6%9E%84%E6%88%90%E4%BB%A3%E7%90%86)
- [Behaivoral Patterns](#behaivoral-patterns)
  - [Chain of Responsibility](#chain-of-responsibility)
    - [定义<责任链>](#%E5%AE%9A%E4%B9%89%E8%B4%A3%E4%BB%BB%E9%93%BE)
    - [UML<责任链>](#uml%E8%B4%A3%E4%BB%BB%E9%93%BE)
    - [构成<责任链>](#%E6%9E%84%E6%88%90%E8%B4%A3%E4%BB%BB%E9%93%BE)
  - [Command](#command)
    - [定义<命令>](#%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4)
    - [UML<命令>](#uml%E5%91%BD%E4%BB%A4)
    - [构成<命令>](#%E6%9E%84%E6%88%90%E5%91%BD%E4%BB%A4)
  - [Interpreter](#interpreter)
    - [定义<解释>](#%E5%AE%9A%E4%B9%89%E8%A7%A3%E9%87%8A)
    - [UML<解释>](#uml%E8%A7%A3%E9%87%8A)
    - [构成<解释>](#%E6%9E%84%E6%88%90%E8%A7%A3%E9%87%8A)
  - [Iterator](#iterator)
    - [定义<迭代>](#%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3)
    - [UML类图<迭代>](#uml%E7%B1%BB%E5%9B%BE%E8%BF%AD%E4%BB%A3)
    - [构成<迭代>](#%E6%9E%84%E6%88%90%E8%BF%AD%E4%BB%A3)
  - [Mediator](#mediator)
    - [定义<中介>](#%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BB%8B)
    - [UML<中介>](#uml%E4%B8%AD%E4%BB%8B)
    - [构成<中介>](#%E6%9E%84%E6%88%90%E4%B8%AD%E4%BB%8B)
  - [Memento](#memento)
    - [定义<备忘>](#%E5%AE%9A%E4%B9%89%E5%A4%87%E5%BF%98)
    - [UML<备忘>](#uml%E5%A4%87%E5%BF%98)
    - [构成<备忘>](#%E6%9E%84%E6%88%90%E5%A4%87%E5%BF%98)
  - [Observer](#observer)
    - [定义<观察>](#%E5%AE%9A%E4%B9%89%E8%A7%82%E5%AF%9F)
    - [UML<观察>](#uml%E8%A7%82%E5%AF%9F)
    - [构成<观察>](#%E6%9E%84%E6%88%90%E8%A7%82%E5%AF%9F)
  - [State](#state)
    - [定义<状态>](#%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81)
    - [UML<状态>](#uml%E7%8A%B6%E6%80%81)
    - [构成<状态>](#%E6%9E%84%E6%88%90%E7%8A%B6%E6%80%81)
  - [Strategy](#strategy)
    - [定义<策略>](#%E5%AE%9A%E4%B9%89%E7%AD%96%E7%95%A5)
    - [UML<策略>](#uml%E7%AD%96%E7%95%A5)
    - [构成<策略>](#%E6%9E%84%E6%88%90%E7%AD%96%E7%95%A5)
  - [Template Method](#template-method)
    - [定义<模板方法>](#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95)
    - [UML<模板方法>](#uml%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95)
    - [构成<模板方法>](#%E6%9E%84%E6%88%90%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95)
  - [Visitor](#visitor)
    - [定义<访问>](#%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE)
    - [UML<访问>](#uml%E8%AE%BF%E9%97%AE)
    - [构成<访问>](#%E6%9E%84%E6%88%90%E8%AE%BF%E9%97%AE)
---
# Creational Patterns
## Abstact Factory
### 定义<抽象工厂>
提供一个接口，可以在不指定具体产品类的情况下，创建一个互相关联或依靠的产品族。

频率：上

### UML<抽象工厂>
![UMLAbFa](\umlimage\umlabstractfactory.png "抽象工厂")


### 构成<抽象工厂>
该模式参与类及对象：
* AbstractFactory(ContinentFactory)
  * 声明一个接口，其操作为创建抽象产品
* ConcreteFactory(AfricaFactory,AmericaFactory)
  * 实现抽象工厂的操作，创建具体产品对象
* AbstractProduct(Herbivore,Carnivore)
  * 声明一个用于产品对象的接口
* Product(Wildebeest,Lion,Bison,Wolf)
  * 定义一个产品对象，通过响应具体工厂来创建
  * 实现抽象产品接口
* Client(AnimalWorld)   
  * 使用抽象工厂和抽象产品定义的接口

## Builder
### 定义<建造>
将一个复杂对象的ctor从它的表现分离，这样同样的ctor过程可以创建不同的表现。

频率：中下

### UML<建造>
![Builder](\umlimage\umlbuilder.png "建造者模式")

### 构成<建造>
该模式中参与的类和对象：
* Builder(VehicleBuilder)
  * 指定一个抽象接口，用于创建产品对象的一部分
* ConcreteBuilder(MotorCycleBuilder,CarBuilder,ScooterBuilder)
  * 构建和组合产品的部分，通过实现建造接口
  * 定义并且追踪其创建的表现内容
  * 提供接口，用于检索产品
* Director(Shop) 
  * 构建对象，使用建造接口
* Product(Vehicle)
  * 在构建下表现复杂对象。具体建造者建造对象的内部表现并且定义组合过程
  * 包含类，其中包含组成成分，包含组合各部分成为一个最终结果的接口


## Factory Method
### 定义<工厂方法>
定义一个用来创建对象的接口，但是让子类来决定需要实例化哪一个类。工厂方法让类顺从子类来实例化。

频率：上

### UML<工厂方法>
![FactoryMethod](\umlimage\umlfactorymethod.png "工厂方法模式")

### 构成<工厂方法>
参与该模式的类和对象：
* Product(Page)
  * 定义工厂方法所创建的对象的接口
* ConcreteProduct(SkillPage,EducationPage,ExperiencePage)
  * 实现产品接口
* Creator(Document)
  * 声明工厂方法，该方法会返回一个产品类型的对象。生成器可能也会定义一个默认的工厂方法的实现，该实现会返回一个默认的具体产品对象。
  * 可能会调用工厂方法来创建一个产品对象。
* ConcreteCreator(Report,Resume)    
  * 覆写工厂方法，来返回一个具体产品实例。

## Prototype
### 定义<原型>
使用原型化的实例，以指定欲创建对象的种类，并且通过复制这些原型，以创建新的对象。

频率：中

### UML<原型>
![Prototype](\umlimage\umlprototype.png "原型模式")

### 构成<原型>
该模式中参与的类和对象：
* Prototype(ColorPrototype)
  * 声明一个接口，用于克隆自身
* ConcretePrototype(Color)
  * 实现一个操作，用于克隆自身
* Client(ColorManager)
  * 创建一个新的对象，通过请求原型自我复制

## Singleton
### 定义<单例>
确保一个类仅有一个实例，并且提供一个全局获取点。

频率： 中上
### UML<单例>
|Singleton|
|:---|
|-instance:Singleton|
|-Singleton() <br/> +Instance():Singleton|

### 构成<单例>
参与此模式的类和对象：  
* Singleton(LoadBalancer)  
    * 定义一个能够让客户端获取的唯一实例  
    * 对创建和维护自身唯一性的响应
### 运用<单例>
使用private ctor和static readonly的instance，可以实现惰性初始化以及线程安全性。
``` C#
private static readonly Singleton _instance = new Singleton();
private Singleton(){}
```

---
# Structual Patterns
## Adapter
### 定义<适配>
转化类的接口为另一个客户希望的接口。适配器可以使多个接口不兼容的类一起工作。

频率：中上

### UML<适配>
![Adapter](\umlimage\umladapter.png "适配器模式")

### 构成<适配>
该模式中参与的类和对象：
* Target(ChemicalCompound)
  * 定义一个被客户端使用的指定域接口
* Adapter(Compound)
  * 给目标接口适配一个适配接口
* Adaptee(ChemicalDatabank) 
  * 定义一个已经存在的需要适配的接口
* Client(AdapterApp)  
  * 与符合目标接口的对象合作

## Bridge
### 定义<桥接>
将一个抽象从其实现去耦，这样两者可以分别变化。

频率：中

### UML<桥接>
![Bridge](\umlimage\umlbridge.png "桥接模式")

### 构成<桥接>
该模式中参与的类和对象：
* Abstraction(BusinessObject)
  * 定义抽象的接口
  * 维护类型实现器对象的引用
* RefinedAbstraction(CustomersBusinessObject)
  * 扩展抽象类定义的接口
* Implementor(DataObject)
  * 定义实现类型的接口。该接口不需要精确符合抽象类的接口；实际上这两个接口可以完全不同。通常实现的接口仅仅提供原始操作，抽象类提供基于这些原始操作的高层级操作
* ConcreteImplementor(CustomersDataObject)
  * 实现实现器接口，定义其具体实现

## Composite
### 定义<组合>
将对象们组合成树结构，以表现部分-整体层级。组合模式让客户将单独对象和对象的组合成分一致对待。

频率：中上

### UML<组合>
![Composite](\umlimage\umlcomposite.png "组合模式")

### 构成<组合>
该模式中参与的类和对象：
* Component(DrawingElement)
  * 声明组合中的对象的接口
  * 为接口实现默认的行为，对所有类是共用的
  * 声明一个接口，用来访问和管理子成员
  * (可选)定义一个接口，用来在递归结构中访问某一成员的父,并在适当的时候实现这个接口
* Leaf(PrimitiveElement)
  * 表现组合中的叶子对象。叶无子
  * 定义组合中原始对象的行为
* Composite(CompositeElement)
  * 定义组合中含子的成员的行为
  * 存储子成员
  * 在成员接口内，实现子相关的操作
* Client(CompositeApp)
  * 通过成员接口，处理组合中的对象

## Decorator
### 定义<装饰>
给一个对象动态的附加额外的职责。装饰为子类的功能扩展提供一个弹性的选择

频率：中

### UML<装饰>
![Decorate](\umlimage\umldecorate.png "装饰模式")

### 构成<装饰>
该模式中参与的类和对象为：
* Component(LibraryItem)
  * 为需要动态增添职责的类定义接口
* ConcreteComponent(Book,Video)
  * 定义一个能够附加额外职责的对象
* Decorator(Decorator)
  * 维护对Component对象的引用，定义符合Component接口的接口
* ConcreteDecorator(Borrowable)
  * 为component增加职责

## Facade
### 定义<外观>
在一个子系统里，为一个接口集，提供一个统一的接口。
表面模式定义了一个高层级的接口，从而使子系统更容易使用。

频率：上

### UML<外观>
![facade](/umlimage/umlfacade.png "外观模式")

### 构成<外观>
该模式下参与的类和对象：
* Facade(MortgageApplication)
  * 知晓应该为请求响应哪一个子系统
  * 委托适当的子系统对象给客户请求
* Subsystem classes(Bank,Credit,Loan)
  * 实现子系统函数
  * 处理被外观对象分配的工作
  * 不具有外观的知识，也不含有外观的引用


## Flyweight
### 定义<享元,蝇量级>
蝇量级模式，使用共享以高效支持大数量的细微粒度的对象

频率：下

### UML<享元>
![Flyweight](\umlimage\umlflyweight.png "享元模式")

### 构成<享元>
该模式中参与的类和对象：
* Flyweight(Character)
  * 声明一个接口，通过该接口，共享元能接受外部状态并在其上行动。
* ConcreteFlyweight(CharacterA,CharacterB,...,CharacterZ)
  * 实现Flyweight接口，并为任何存在的外部状态增加存储。具体享元对象必须是可共享的。任何存储的状态必须是内部的，必须是独立于具体享元对象上下文的。
* UnsharedConcreteFlyweight(not used)
  * 并非所有享元子类需要共享。享元接口允许共享，但并非强制。在享元对象结构的一些层级上，非共享具体享元对象通常有具体享元对象的子
* FlyweightFactory(CharacterFactory)
  * 创建和管理享元对象
  * 确保享元适当的共享。当客户请求一个享元时，享元工厂对象出具一个已经存在的实例或创建一个新的。
* Client(FlyweightApp) 
  * 维护对享元的引用
  * 计算或存储享元的外部状态

## Proxy
### 定义<代理>
为另一个对象提供一个代理或占位符，用来控制对其的访问

频率：中上

### UML<代理>
![Proxy](\umlimage\umlproxy.png "代理模式")

### 构成<代理>
参与该模式的类和对象为：
* Proxy(MathProxy)
  * 维护一个引用，让代理访问实际主体。如果实际主体和主体接口是一致的话，则代理能够代表主体。
  * 为实际主体提供相同的接口，以便于代理来替代.
  * 控制对实际主体的访问，并且能够负责创建和删除它。
  * 依赖代理类型的其他责任：
    *  远程代理(remote proxy)是用来编码一个请求及其语句，并且从不同的地址空间发送被编码的请求给实际主体
    *  虚拟代理(virtual proxy)能够缓存关于实际主体的额外信息，以便于代理能够延迟访问。例如，来自Motivation的图像代理会缓存实际图片的扩展。
    *  保护代理(protection proxy)会检查调用者是否具有执行请求的访问许可。
* Subject(IMath)
  * 定义实际主体和代理的公用接口，这样代理可以用在任何实际主体的地方。
* RealSubject(Math)
  * 定义一个实际的主体，可以被代理所代表。

---
# Behaivoral Patterns
## Chain of Responsibility
### 定义<责任链>
通过给多个对象处理请求的机会，避免将请求的发送方与其接收方耦合。将接收对象链起来，并沿着链传递请求，直到对象处理它为止。

频率：中下

### UML<责任链>
![Chain of Responsibility](\umlimage\umlchain.png "责任链模式")

### 构成<责任链>
该模式中参与的类和对象：
* Handler(Approver)
  * 定义处理请求的接口
  * (可选)实现继任者链接
* ConcreteHandler(Director,VicePresident,President)
  * 处理其负责的请求
  * 可以访问它的继承者
  * 如果混凝土处理程序可以处理请求，它就会这样做；否则，它将请求转发给它的继任者
* Client(ChainApp)
  * 将请求初始化为链上的具体处理对象

## Command
### 定义<命令>
将一个请求封装为对象，从而让你可以使用不同的请求、队列或者日志请求来参数化客户端，并且支持撤销操作。

频率：中上

### UML<命令>
![Command](\umlimage\umlcommand.png "命令模式")

### 构成<命令>
该模式中参与的类和对象为：
* Command(Command)
  * 声明一个接口以执行一个操作
* ConcreteCommand(CalculatorCommand)
  * 在接受对象和动作之间定义一个绑定
  * 通过调用接收器上的响应操作来实现执行
* Client(CommandApp)
  * 创建一个具体命令对象，设置它的接收器
* Invoker(User) 
  * 询问命令来执行请求
* Receiver(Calculator) 
  * 直到如何执行与执行请求关联的操作

## Interpreter
### 定义<解释>
给定一个语言，定义其语法的表现，以及使用该表现来解释该语言中的句子的解释器。

频率：下

### UML<解释>
![Interpreter](\umlimage\umlinterpreter.png "解释器模式")

### 构成<解释>
该模式中参与的类和对象：
* AbstractExpression(Expression)
  * 声明执行操作的接口
* TerminalExpression(ThousandExpression,HundredExpression,TenExpression,OneExpression)
  * 实现与语法中的终端符号相关联的解释操作
  * 句子中的每个终端符号都需要一个实例
* NonterminalExpression(not used)
  * 每一个类都是语法中的每个规则R::=R1R2..Rn所需要的
  * 为每个R1到Rn符号，维护抽象表达式类型的实例变量
  * 实现对语法中的非终结符号的解释操作。解释器通常在从R1到Rn的变量表现上递归调用自身。
* Context(Context)
  * 包含解释器全局的信息
* Client(InterpreterApp)
  * 构建(或给定)抽象语法树，表现语法定义的语言中的特定句子。抽象语法树有非终端表达式和终端表达式类的实例组装而成
  * 调用解释器操作

## Iterator
### 定义<迭代>
提供一种既能顺序获取集合对象中元素，又不会暴露潜在内容的方法。

频率：上

### UML类图<迭代>

![截图版本](\UmlImage\UmlIterator.png "迭代器")


### 构成<迭代>
该模式所参与的类和对象：
* Iterator(AbstractIterator)
  * 定义一个接口，用来获取和遍历元素
* ConcreteIterator(Iterator)
  * 实现迭代器接口
  * 在遍历集合时，追踪当前位置
* Aggregate(AbstractCollection)
  * 定义一个接口来创建迭代器对象
* ConcreteAggregate(Collection) 
  * 实现迭代器创建器接口,返回一个适当的实例


## Mediator
### 定义<中介>
定义封装一组对象如何交互的对象。
中介通过组织对象显式地互相引用来促进松散耦合，并且允许你独立的更改它们的交互。

频率：中下

### UML<中介>
![Mediator](\umlimage\umlmediator.png "中介模式")

### 构成<中介>
该模式中参与的类和对象：
* Mediator(IChatroom)
  * 定义用于与同事对象通信的接口
* ConcreteMediator(Chatroom)
  * 通过协调同事对象实现协作行为
  * 了解并维护其同事
* Colleague classes(Participant)
  * 每个同事类都知道其中介对象
  * 每一个同事与它的调解员进行通信时，它本来可以与另一个同事进行通信


## Memento
### 定义<备忘>
在不违反封装的情况下，捕获并外部化对象的内部状态，以便稍后将对象恢复到这种状态。

频率：下

### UML<备忘>
![Memento](\umlimage\umlmemento.png "备忘录模式")

### 构成<备忘>
该模式中参与的对象和类：
* Memento(Memento)
  * 存储发起者对象的内部状态。备忘录可根据发起者的酌情决定，尽可能多地或尽可能少地保存发端人的内部状态。
  * 阻止发起者以外的对象访问。备忘录实际上有两个接口。看管者看到备忘录的狭窄接口，它只能将备忘录传递给其他对象。与此相反，发起者看到的是一个广泛的接口，它允许访问所有必要的数据来恢复到以前的状态。理想状态下，只有产生备忘录的发起者才被允许访问备忘录的内部状态。
* Originator(SalesProspect)
  * 创建包含当前内部状态快照的备忘录
* Caretaker(Caretaker)
  * 是否对备忘录的保管负责
  * 不要操作或检查备忘录的内容


## Observer
### 定义<观察>
在对象间定义一个一对多的从属关系，当一个对象改变状态时，其所有从属都会被通知，并且自动更新。

频率：上

### UML<观察>
![Observer](\umlimage\umlobserver.png "观察者模式")

### 构成<观察>
该模式中参与的类和对象：
* Subject(Stock)
  * 知晓它的观察者。任意数量的观察者对象会观察此主体
  * 提供一个接口，用来附加和分离观察者对象
* ConcreteSubject(IBM)
  * 存储具体观察者感兴趣的状态
  * 在状态发生变化的时候，发送一个通知给它的观察者
* Observer(IInvestor)
  * 为应该被通知主体变更的对象们，定义一个更新接口
* ConcreteObserver(Investor)
  * 维护一个对具体主体对象的引用
  * 存储与主体保持一致的状态
  * 实现观察者的更新接口，以保证其状态与主体一致

## State
### 定义<状态>
允许对象在其内部状态变化时改变其行为。对象会改变它的类。

频率：中

### UML<状态>
![](\umlimage\umlstate.png "状态模式")

### 构成<状态>
该模式中参与的类和对象：
* Context(Account)  
  * 定义客户感兴趣的接口
  * 维护定义了当前状态的具体状态子类的实例
* State(State)
  * 定义接口用于封装与特定上下文状态相关的行为
* Concrete State(RedState,SilverState,GoldState)
  * 每一个子类型都实现一个与上下文状态相关联的行为

## Strategy
### 定义<策略>
定义一个算法族，封装每一个，使他们可交换。策略模式使得算法能够根据使用它的客户来分别变化。

频率：中上

### UML<策略>
![Strategy](\umlimage\umlstrategy.png "策略模式")

### 构成<策略>
该模式中参与的类和对象：
* Strategy(SortStrategy)
  * 声明一个所有支持算法的公用接口。上下文使用这个算法来调用定义在具体策略中的算法。
* ConcreteStrategy(QuickSort,ShellSort,MergeSort)
  * 使用了策略接口的算法的实现
* Context(SortedList)
  * 用具体策略对象来配置
  * 维护一个对策略对象的引用
  * 可以定义一个让策略访问其数据的接口


## Template Method
### 定义<模板方法>
在操作中定义算法的框架，将一些步骤推迟到子类中。模板允许子类在不改变算法结构的情况下重新定义算法的某些步骤。

频率：中

### UML<模板方法>
![Template Method](\umlimage\umltemplate.png "模板方法模式")

### 构成<模板方法>
该模式中参与的类和对象：
* AbstractClass
  * 定义抽象原始操作(具体子类定义)以实现算法的步骤
  * 实现一个模板方法(定义算法的骨架)。模板方法调用原始操作和抽象类或其他类中定义的操作
* ConcreteClass
  * 实现原始操作以实现子类相关的算法步骤


## Visitor
### 定义<访问>
表现一个操作，该操作能够运行在对象结构的元素上。访问者使你在不需要改变操作的元素的类的情况，定义一个新的操作。

频率：下

### UML<访问>
![Visitor](\umlimage\umlvisitor.png "访问者模式")

### 构成<访问>
该模式中参与的类和对象：
* Visitor(Visitor)
  * 为对象结构中的每个具体元素声明访问操作。操作的名称和签名标识发送访问请求给访问者的类。这允许访问者决定被访问元素的具体类。然后访问者可以通过其特定的接口直接访问元素。
* ConcreteVisitor(IncomeVisitor,VacationVisitor)
  * 实现访问者声明的每一个操作。每个操作实现为结构中相应的类或对象定义的算法片段。具体访问者为算法提供上下文并存储本地状态。这种状态经常在结构遍历期间积累结果。
* Element(Element)
  * 定义一个接收操作，该操作将访问者作为语句
* ConcreteElement(Employee) 
  * 实现一个接收操作，该操作将访问者作为语句
* ObjectStructure(Employees)
  * 能够枚举其元素
  * 可以提供一个高层级接口，以允许访问者访问器元素
  * 可以是一个组合模式，或是一个集合如list或set